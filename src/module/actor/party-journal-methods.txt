  /* -------------------------------------------- */
  // Journal methods for party

  async _prepareJournalEntries() {
    // Defensive checks for undefined/null journal structure
    if (!this.actor?.system?.journal) return [];

    const entries = this.actor.system.journal.entries || [];
    const journalId = this.actor.system.journal.journalId;

    if (!journalId || !entries.length) return [];

    // Ensure entries is actually an array
    if (!Array.isArray(entries)) return [];

    const journal = game.journal.get(journalId);
    if (!journal) return [];

    const typeLabels = {
      party: "Party",
      roster: "Roster",
      hireling: "Hireling",
      hub: "Hub",
      treasure: "Treasure",
      quest: "Quest",
      ally: "Ally",
      rival: "Rival",
      session: "Session Lore",
      achievement: "Achievement",
      graveyard: "Graveyard",
    };

    const badgeColors = {
      party: "#620630",
      roster: "#2c5aa0",
      hireling: "#a05c2c",
      hub: "#2ca05c",
      treasure: "#5c2ca0",
      quest: "#a0862c",
      ally: "#2c8da0",
      rival: "#a02c5c",
      session: "#5ca02c",
      achievement: "#d4af37",
      graveyard: "#333333",
    };

    const preparedEntries = [];
    for (const entry of entries) {
      if (!entry || !entry.pageId) continue;

      const page = journal.pages.get(entry.pageId);
      if (!page) continue;

      const entryData = page.getFlag(SYSTEM_ID, "entryData") || {};
      const gameDate = page.getFlag(SYSTEM_ID, "gameDate") || null;
      const realDate = new Date(entry.timestamp || Date.now());

      // Enrich HTML content for all text fields
      const enrichedData = {};
      if (entryData && typeof entryData === 'object') {
        for (const [key, value] of Object.entries(entryData)) {
          if (typeof value === 'string' && value.trim()) {
            // Enrich HTML to convert entity links (@UUID) to clickable links
            enrichedData[key] = await TextEditor.enrichHTML(value, {
              async: true,
              relativeTo: this.actor,
            });
          } else {
            enrichedData[key] = value;
          }
        }
      }

      preparedEntries.push({
        id: entry.id,
        type: entry.type,
        pageId: entry.pageId,
        typeLabel: typeLabels[entry.type] || entry.type,
        badgeColor: badgeColors[entry.type] || "#666666",
        session: entryData.session || null,
        gameDate: gameDate,
        data: enrichedData,
        timestamp: entry.timestamp,
        timestampFormatted: realDate.toLocaleDateString() + " " + realDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      });
    }

    // Sort by timestamp (newest first)
    preparedEntries.sort((a, b) => b.timestamp - a.timestamp);

    return preparedEntries;
  }

  async _onJournalCreate() {
    const journalData = {
      name: `${this.actor.name} Chronicle`,
      ownership: {
        [game.user.id]: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER,
      },
    };

    // Copy actor ownership to journal
    if (this.actor.ownership && typeof this.actor.ownership === 'object') {
      for (const [userId, level] of Object.entries(this.actor.ownership)) {
        if (userId !== "default") {
          journalData.ownership[userId] = level;
        }
      }
    }

    const journal = await JournalEntry.create(journalData);

    await this.actor.update({
      "system.journal.journalId": journal.id,
    });

    ui.notifications.info(`Party journal created`);
    this.render(false);
  }

  async _onJournalOpen() {
    const journalId = this.actor.system.journal?.journalId;
    if (!journalId) return;

    const journal = game.journal.get(journalId);
    if (journal) {
      journal.sheet.render(true);
    }
  }

  async _onJournalSimpleQuest() {
    const journalId = this.actor.system.journal?.journalId;
    if (!journalId) return;

    const journal = game.journal.get(journalId);
    if (!journal) return;

    // Check if simple-quest is active
    if (!game.modules.get("simple-quest")?.active) {
      ui.notifications.warn("Simple Quest module is not active");
      return;
    }

    // Open the journal in simple-quest
    if (ui.simpleQuest) {
      ui.simpleQuest.openToPage(journal.uuid);
    }
  }

  async _onJournalAddEntry(entryType) {
    if (!entryType) return;

    const entryData = {
      type: entryType,
      data: {},
    };

    new AcksPartyJournalEntryEditor(this.actor, entryData, {
      top: this.position.top + 40,
      left: this.position.left + (this.position.width - 500) / 2,
    }).render(true);
  }

  async _onJournalEditEntry(entryId) {
    const entries = this.actor.system.journal?.entries || [];
    const entry = entries.find(e => e.id === entryId);

    if (!entry) return;

    const journalId = this.actor.system.journal?.journalId;
    const journal = game.journal.get(journalId);
    if (!journal) return;

    const page = journal.pages.get(entry.pageId);
    if (!page) return;

    const entryData = {
      id: entry.id,
      type: entry.type,
      data: page.getFlag(SYSTEM_ID, "entryData") || {},
      timestamp: entry.timestamp,
      gameDate: page.getFlag(SYSTEM_ID, "gameDate") || "",
    };

    new AcksPartyJournalEntryEditor(this.actor, entryData, {
      top: this.position.top + 40,
      left: this.position.left + (this.position.width - 500) / 2,
    }).render(true);
  }

  async _onJournalDeleteEntry(entryId) {
    const confirmed = await Dialog.confirm({
      title: "Delete Journal Entry",
      content: "<p>Are you sure you want to delete this journal entry?</p>",
    });

    if (!confirmed) return;

    const entries = this.actor.system.journal?.entries || [];
    const entry = entries.find(e => e.id === entryId);

    if (!entry) return;

    // Delete the journal page
    const journalId = this.actor.system.journal?.journalId;
    const journal = game.journal.get(journalId);
    if (journal) {
      const page = journal.pages.get(entry.pageId);
      if (page) {
        await page.delete();
      }
    }

    // Remove from actor's entry list
    const updatedEntries = entries.filter(e => e.id !== entryId);
    await this.actor.update({
      "system.journal.entries": updatedEntries,
    });

    ui.notifications.info("Journal entry deleted");
    this.render(false);
  }

  async _onJournalViewPage(pageId) {
    const journalId = this.actor.system.journal?.journalId;
    if (!journalId) return;

    const journal = game.journal.get(journalId);
    if (!journal || !journal.pages) return;

    const page = journal.pages.get(pageId);
    if (!page) return;

    // Use page's show method instead of rendering journal with pageId
    // This avoids Foundry's iteration issues when the journal structure is complex
    if (page.sheet) {
      page.sheet.render(true);
    } else {
      // Fallback: render journal sheet without pageId option, then navigate
      const sheet = journal.sheet;
      sheet.render(true);
      // Wait for sheet to render, then try to navigate to the page
      setTimeout(() => {
        if (sheet._pages) {
          sheet._pages.pageIndex = journal.pages.contents.indexOf(page);
          sheet.render(false);
        }
      }, 100);
    }
  }

  _onJournalFilter(html) {
    // Get all checked filter values
    const checkedTypes = [];
    html.find(".journal-type-filter:checked").each(function() {
      checkedTypes.push($(this).val());
    });

    // Show/hide entries based on checked filters
    const entries = html.find(".journal-entry-card");
    entries.each(function() {
      const entryType = $(this).data("entryType");
      if (checkedTypes.includes(entryType)) {
        $(this).show();
      } else {
        $(this).hide();
      }
    });
  }

  _onJournalSort(html, sortOrder) {
    const container = html.find(".journal-entry-list");
    const entries = container.find(".journal-entry-card").get();

    entries.sort((a, b) => {
      const aCard = $(a);
      const bCard = $(b);

      if (sortOrder === "newest") {
        // Already sorted by timestamp in getData
        return 0;
      } else if (sortOrder === "oldest") {
        // Reverse current order
        return aCard.index() > bCard.index() ? -1 : 1;
      } else if (sortOrder === "type") {
        // Sort by entry type
        const aType = aCard.data("entryType");
        const bType = bCard.data("entryType");
        return aType.localeCompare(bType);
      }
      return 0;
    });

    // Reorder DOM elements
    container.append(entries);
  }
